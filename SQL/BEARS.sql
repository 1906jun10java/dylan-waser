--DB CREATION SCRIPTS OFTEN BEGIN WITH 'DROP' STATEMENTS TO AVOID CLASHES WITH EXISTING TABLES
DROP TABLE BEAR;
/
DROP TABLE BEAR_TYPE;
/
DROP TABLE CAVE;
/ 
DROP TABLE BEEHIVE;
/ 
DROP TABLE BEAR_BEEHIVE;
/

--TABLE CREATION WITH PRIMARY KEYS

CREATE TABLE BEAR (
    BEAR_ID INTEGER PRIMARY KEY,
    BEAR_NAME VARCHAR2(100), --100 CHARACTERS OF SPACE, 
    -- VARCHAR2 INTERPRETS NULL AND EMPTY STRING AS SAME VALUE (VARCHAR DOES NOT)
    BIRTHDATE DATE,
    WEIGHT NUMBER(6, 2) DEFAULT 200.00,
    BEAR_TYPE_ID INTEGER NOT NULL, --APPLIED A NOT NULL CONSTRAINT, WILL BE FK
    CAVE_ID INTEGER --WILL BE A NULLABLE FK
);
/
CREATE TABLE BEAR_TYPE (
    BEAR_TYPE_ID INTEGER PRIMARY KEY,
    BEAR_TYPE_NAME VARCHAR2(100)
);
/
CREATE TABLE CAVE (
    CAVE_ID INTEGER PRIMARY KEY,
    CAVE_NAME VARCHAR2(100),
    MAX_BEARS INTEGER DEFAULT 4
);
/
CREATE TABLE BEEHIVE (
    BEEHIVE_ID INTEGER PRIMARY KEY,
    LBS_HONEY NUMBER(5,2) DEFAULT 75.00
);
/
CREATE TABLE BEAR_BEEHIVE (
    BEAR_ID INTEGER,
    BEEHIVE_ID INTEGER,
    PRIMARY KEY (BEAR_ID, BEEHIVE_ID) --COMPOSITE PRIMARY KEY
);
/

--FOREIGN KEY CONSTRAINTS

--CONSTRAINT: RULE PLACE ON THE CONTENTS OF A TABLE, 
--LIMITING WHAT MAY BE INSERTED INTO A COLUMN
--TYPES: PRIMARY KEY, FOREIGN KEY, UNIQUE, CHECK (INCLUDES NOT NULL)

ALTER TABLE BEAR
ADD CONSTRAINT FK_BEAR_BEAR_TYPE
FOREIGN KEY (BEAR_TYPE_ID) REFERENCES BEAR_TYPE(BEAR_TYPE_ID);
/
ALTER TABLE BEAR
ADD CONSTRAINT FK_BEAR_CAVE
FOREIGN KEY (CAVE_ID) REFERENCES CAVE(CAVE_ID);
/
ALTER TABLE BEAR_BEEHIVE
ADD CONSTRAINT FK_BEAR_BEEHIVE_BEAR
FOREIGN KEY (BEAR_ID) REFERENCES BEAR(BEAR_ID);
/
ALTER TABLE BEAR_BEEHIVE
ADD CONSTRAINT FK_BEAR_BEEHIVE_BEEHIVE
FOREIGN KEY (BEEHIVE_ID) REFERENCES BEEHIVE(BEEHIVE_ID);
/

--ADD SOME DATA (DML)
--TWO WAYS:
INSERT INTO BEAR_TYPE VALUES(1, 'GRIZZLY');
INSERT INTO BEAR_TYPE (BEAR_TYPE_ID, BEAR_TYPE_NAME) VALUES (2, 'POLAR');

INSERT ALL
INTO CAVE
VALUES(1, 'TAMPA', 10)
INTO CAVE(CAVE_ID, CAVE_NAME)
VALUES(37, 'NASHVILLE')
SELECT * FROM DUAL; --DUAL IS A DUMMY TABLE 

INSERT INTO CAVE VALUES(2, 'MIAMI', 4);

INSERT ALL
INTO BEAR (BEAR_ID, BEAR_NAME, BIRTHDATE, BEAR_TYPE_ID, CAVE_ID)
VALUES(72, 'Barry', TO_DATE('1987-07-14', 'yyyy-mm-dd'), 2, 37)
INTO BEAR (BEAR_ID, BEAR_NAME, BIRTHDATE, WEIGHT, BEAR_TYPE_ID, CAVE_ID)
VALUES(24, 'Berneice', TO_DATE('1997-07-14', 'yyyy-mm-dd'), 600.00, 1, 37)
SELECT * FROM DUAL;
/

--TRUNCATE TABLE BEAR;   --LOSE DATA NOT THE STRUCTURE

--WONT WORK, DUPLICATE PK
INSERT INTO BEAR (BEAR_ID, BEAR_NAME, BIRTHDATE, BEAR_TYPE_ID, CAVE_ID)
VALUES(72, 'Barry', TO_DATE('1987-07-14', 'yyyy-mm-dd'), 5, 37)
/


--CREATE SEQUENCES: PRODUCE SEQUENTIAL VALUES
CREATE SEQUENCE SQ_BEAR_PK
START WITH 1000
INCREMENT BY 1;
/
CREATE SEQUENCE SQ_BEAR_TYPE_PK
START WITH 1000
INCREMENT BY 1;
/
CREATE SEQUENCE SQ_CAVE_PK
START WITH 1000
INCREMENT BY 1;
/
CREATE SEQUENCE SQ_BEEHIVE_PK
START WITH 1000
INCREMENT BY 1;


--TRIGGES: BLOCK OF CODE TAHT WILL EXECUTE IN RESPONSE TO A DML STATEMENT
--SO INSERT, UPDATE, DELETE
--TRIGGERS CAN BE BEFORE OR AFTER

CREATE OR REPLACE TRIGGER TR_INSERT_BEAR
BEFORE INSERT ON BEAR -- SPECIFY OPERATION, BEFORE/AFTER, AND TABLE
FOR EACH ROW
BEGIN
    SELECT SQ_BEAR_PK.NEXTVAL INTO :NEW.BEAR_ID FROM DUAL;
END;
/
CREATE OR REPLACE TRIGGER TR_INSERT_BEAR_TYPE
BEFORE INSERT ON BEAR_TYPE -- SPECIFY OPERATION, BEFORE/AFTER, AND TABLE
FOR EACH ROW
BEGIN
    SELECT SQ_BEAR_TYPE_PK.NEXTVAL INTO :NEW.BEAR_TYPE_ID FROM DUAL;
END;
/
CREATE OR REPLACE TRIGGER TR_INSERT_CAVE
BEFORE INSERT ON CAVE -- SPECIFY OPERATION, BEFORE/AFTER, AND TABLE
FOR EACH ROW
BEGIN
    SELECT SQ_CAVE_PK.NEXTVAL INTO :NEW.CAVE_ID FROM DUAL;
END;
/
CREATE OR REPLACE TRIGGER TR_INSERT_BEEHIVE
BEFORE INSERT ON BEEHIVE -- SPECIFY OPERATION, BEFORE/AFTER, AND TABLE
FOR EACH ROW
BEGIN
    SELECT SQ_BEEHIVE_PK.NEXTVAL INTO :NEW.BEEHIVE_ID FROM DUAL;
END;
/

--TRY IT OUT!
INSERT INTO BEAR(BEAR_NAME, BIRTHDATE, BEAR_TYPE_ID, WEIGHT)
VALUES('BRUCE', TO_DATE('1999-04-04', 'yyyy-mm-dd'), 2, 300);

--give bruce somehwere to live
UPDATE BEAR SET CAVE_ID = 1 --SPECIFY TABLE, COLUMN TO BE UPDATED, AND CONDITION
WHERE BEAR_NAME = 'BRUCE';

SELECT BEAR_NAME, BIRTHDATE FROM BEAR
WHERE BEAR_TYPE_ID = 1
ORDER BY BEAR_NAME ASC; -- ASCENDING IS DEFAULT, OTHERWISE 'DESC' FOR DESCENDING


SELECT * FROM BEAR
ORDER BY BEAR_TYPE_ID, WEIGHT;

--GROUP BY: WILL GIVE ALL DISTINCT VALUES IN THE SPECIFIED COLUMN

--SELECT ALL DISTINCT CAVES TO WHICH BEARS ARE MAPPED
--ONLY INCLUDE COLUMNS IN RESULT SET RELATED TO WHAT IS BEING GROUPED BY
SELECT CAVE_ID
FROM BEAR
GROUP BY CAVE_ID;

--HOW MANY BEARS PER CAVE?
SELECT CAVE_ID, COUNT(BEAR_ID) AS NUMBEAR --SYSTEM DEFINED AGGREGATE FUNCTION
FROM BEAR
GROUP BY CAVE_ID;

--SELECT ALL CAVES WITH <2 BEARS (JUST CAVE #1 FOR NOW)
--WHERE ONLY WORKS ON ORIGINAL DATE SET
--HAVING WORK WITH AGGREGATE FUNCTIONS
SELECT CAVE_ID, COUNT(BEAR_ID) AS NUMBEAR
FROM BEAR
GROUP BY CAVE_ID
HAVING COUNT(BEAR_ID) < 3; --ALLOWS US TO PLACE RESTRICTIONS ON AGGREGATIONS OF DATA


--JOINS:
--ALLOW THE COMBINATION OF DATA FROM MULTIPLE TABLES INTO A SINGLE RESULT SET
--LEFT OUTER JOIN
SELECT * FROM BEAR B --ALIAS BEAR TABLE TO B
LEFT JOIN CAVE C ON B.CAVE_ID = C.CAVE_ID;

--FULL OUTER JOIN
SELECT * FROM BEAR B --ALIAS BEAR TABLE TO B
FULL JOIN CAVE C ON B.CAVE_ID = C.CAVE_ID;

--CROSS JOIN
SELECT *
FROM BEAR B
CROSS JOIN CAVE;

--ADD A CAVELESS BEAR
INSERT INTO BEAR(BEAR_NAME, BIRTHDATE, BEAR_TYPE_ID, WEIGHT)
VALUES('BARNABAS', TO_DATE('1999-04-04', 'yyyy-mm-dd'), 2, 300);

--



